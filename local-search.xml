<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RoForm自定义表单</title>
    <link href="undefined2022/02/11/RoForm%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95/"/>
    <url>2022/02/11/RoForm%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="RoForm自定义表单"><a href="#RoForm自定义表单" class="headerlink" title="RoForm自定义表单"></a>RoForm自定义表单</h1><h6 id="自定义表单工具，简单配置，实现清晰，快速创建表单"><a href="#自定义表单工具，简单配置，实现清晰，快速创建表单" class="headerlink" title="自定义表单工具，简单配置，实现清晰，快速创建表单"></a>自定义表单工具，简单配置，实现清晰，快速创建表单</h6><blockquote><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3></blockquote><p><img src="https://raw.githubusercontent.com/luodeCoding/imageStorage/main/imageFolder/formDemo.gif" srcset="/img/loading.gif" alt=""></p><blockquote><h3 id="如何导入"><a href="#如何导入" class="headerlink" title="如何导入"></a>如何导入</h3></blockquote><ol><li><h6 id="项目中导入NEFormTableView，UIHelper，Vender等文件夹；"><a href="#项目中导入NEFormTableView，UIHelper，Vender等文件夹；" class="headerlink" title="项目中导入NEFormTableView，UIHelper，Vender等文件夹；"></a>项目中导入NEFormTableView，UIHelper，Vender等文件夹；</h6></li><li><h6 id="pod中有依赖"><a href="#pod中有依赖" class="headerlink" title="pod中有依赖"></a>pod中有依赖</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;Masonry&apos;, &apos;~&gt; 1.1.0&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;BRPickerView&apos;, &apos;~&gt; 2.7.6&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;HCSStarRatingView&apos;, &apos;~&gt; 1.5&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;QMUIKit&apos;, &apos;~&gt; 4.4.0&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;ReactiveObjC&apos;, &apos;~&gt; 3.1.0&apos;</span><br><span class="line"></span><br><span class="line">pod &apos;SDWebImage&apos;, &apos;~&gt; 5.0&apos;</span><br></pre></td></tr></table></figure></li><li><h6 id="库中包含了图片选择所以需要相册相机权限"><a href="#库中包含了图片选择所以需要相册相机权限" class="headerlink" title="库中包含了图片选择所以需要相册相机权限"></a>库中包含了图片选择所以需要相册相机权限</h6><p>Privacy - Photo Library Usage Description 授权通过相册，选择头像或身份证照片</p><p>Privacy - Camera Usage Description 授权通过相机，进行头像拍摄或扫描二维码</p></li></ol><blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3></blockquote><ol><li><h6 id="初始化表单ViewModel"><a href="#初始化表单ViewModel" class="headerlink" title="初始化表单ViewModel"></a>初始化表单ViewModel</h6></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NECreateDemoViewModel *viewModel = [[NECreateDemoViewModel alloc]init];</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表单数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSArray</span>*&gt;* modelGroups;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSArray</span>*&gt;*)modelGroups&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_modelGroups) &#123;</span><br><span class="line">        <span class="comment">// 根据需求添加不同的formCellModel</span></span><br><span class="line">        _logoImagesModel = [[NEImagePickTableViewCellModel alloc] init];</span><br><span class="line">        _logoImagesModel.title = <span class="string">@"上传俱乐部Logo"</span>;</span><br><span class="line">        _logoImagesModel.mode = <span class="number">1</span>;</span><br><span class="line">        _logoImagesModel.maxPhotoNum = <span class="number">1</span>;</span><br><span class="line">        _logoImagesModel.isNecessary = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// 装进组内</span></span><br><span class="line">        <span class="keyword">self</span>.modelGroups = @[@[_logoImagesModel]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _modelGroups;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><h6 id="初始化表单TableView"><a href="#初始化表单TableView" class="headerlink" title="初始化表单TableView"></a>初始化表单TableView</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NEFormTableView alloc] initWithFrame:<span class="built_in">CGRectZero</span> style:<span class="built_in">UITableViewStyleGrouped</span> models:<span class="keyword">self</span>.viewModel.modelGroups];</span><br></pre></td></tr></table></figure></li><li><h6 id="可以根据自己的业务调整Cell样式和内部逻辑，也可以自定义其他不同的cell；"><a href="#可以根据自己的业务调整Cell样式和内部逻辑，也可以自定义其他不同的cell；" class="headerlink" title="可以根据自己的业务调整Cell样式和内部逻辑，也可以自定义其他不同的cell；"></a>可以根据自己的业务调整Cell样式和内部逻辑，也可以自定义其他不同的cell；</h6></li></ol><blockquote><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3></blockquote><p><a href="https://github.com/luodeCoding/RoForm" target="_blank" rel="noopener">Demo链接</a></p><p>Roder, <a href="https://luodecoding.github.io/" target="_blank" rel="noopener">我的博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CoreData+HandyJSON+AlecrimCoreData实现项目缓存</title>
    <link href="undefined2020/06/04/CoreData-HandyJSON-AlecrimCoreData%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98/"/>
    <url>2020/06/04/CoreData-HandyJSON-AlecrimCoreData%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2>iOS封装CoreData+HandyJson实现本地缓存</h2><blockquote><p>准备工作</p></blockquote><ul><li><h5>选中Tagets->BuildPhases->LinkBinaryWithLibraries 添加CoreData.framework</h5></li><li><h5>使用CocoaPods工具Pod需要使用的相关框架</h5><pre><code>pod &apos;AlecrimCoreData&apos;pod &apos;HandyJSON&apos;, &apos;~&gt; 5.0.1&apos;</code></pre></li></ul><blockquote><p>CoreData基本使用查看上篇博客《CoreData数据持久化》</p></blockquote><p>链接如下：<br><a href="https://luodecoding.github.io/2020/06/03/%E4%BD%BF%E7%94%A8CoreData%E5%81%9A%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/" target="_blank" rel="noopener">CoreData数据持久化</a></p><blockquote><p>配置 PersistentContainer</p></blockquote><ol><li><p>创建PersistentContainer+App.swift</p></li><li><p>代码如下</p><pre><code>import Foundationimport AlecrimCoreDataextension PersistentContainer {    public convenience init(name: String? = nil, bundle: Bundle? = nil) {        try! self.init(name: name,                       managedObjectModel: type(of: self).managedObjectModel(withName: name,                                                                             in: bundle ?? Bundle.main),                       storageType: .disk,                       persistentStoreURL: try! type(of: self).persistentStoreURL(withName: name, inPath: &quot;&quot;),                       persistentStoreDescriptionOptions: nil,                       ubiquitousConfiguration: nil)    }}</code></pre></li></ol><blockquote><p>创建 StorageService.swift</p></blockquote><p>代码如下</p><pre><code>import Foundationimport AlecrimCoreDataimport CoreDataimport HandyJSONpublic final class StorageService: NSObject {    @objc public static let shared = StorageService()    private override init() {}    private lazy var container = PersistentContainer(name: &quot;DataModel&quot;, bundle: nil)}extension NSManagedObjectContext {    fileprivate var dataModel: Query&lt;DataModel&gt; { return Query(in: self) }}extension StorageService {    public func set&lt;T&gt;(_ value: T, forKey defaultName: String) {        let v: String = {            switch value {            case let value as String:                return value            case let value as Int:                return String(value)            case let value as Float:                return String(value)            case let value as Double:                return String(value)            case let value as Bool:                return String(value)            case let value as URL:                return value.absoluteString            default:                fatalError(&quot;无效的类型&quot;)            }        }()        container.performBackgroundTask { context in            let query = context.dataModel.where { \.key == defaultName }            if let model = query.first() {                model.value = v            } else {                let model = DataModel(context: context)                model.key = defaultName                model.value = v            }            if context.hasChanges {                try? context.save()            }        }    }    private func _get(forKey defaultName: String) -&gt; String? {        //        步骤一：获取总代理和托管对象总管        let context = container.viewContext        //        步骤二：建立一个获取的请求        let query = context.dataModel.where { \.key == defaultName }        if let result = query.first() {            return result.value        }        return nil    }    @objc public func remove(forKey defaultName: String) {        container.performBackgroundTask { context in            let fetchRequest: NSFetchRequest&lt;DataModel&gt; = DataModel.fetchRequest()            fetchRequest.predicate = NSPredicate(format: &quot;key==%@&quot;, defaultName)            if let results = try? context.fetch(fetchRequest) {                for result in results {                    context.delete(result)                }                if context.hasChanges {                    try? context.save()                }            }        }    }    // MARK: - 普通类型    @objc public func isExist(forKey defaultName: String) -&gt; Bool {        return _get(forKey: defaultName) != nil    }    @objc public func integer(forKey defaultName: String) -&gt; Int {        let value = _get(forKey: defaultName)        return Int(value ?? &quot;0&quot;) ?? 0    }    @objc public func float(forKey defaultName: String) -&gt; Float {        let value = _get(forKey: defaultName)        return Float(value ?? &quot;0&quot;) ?? 0    }    @objc public func double(forKey defaultName: String) -&gt; Double {        let value = _get(forKey: defaultName)        return Double(value ?? &quot;0&quot;) ?? 0    }    @objc public func string(forKey defaultName: String) -&gt; String {        let value = _get(forKey: defaultName)        return value ?? &quot;&quot;    }    @objc public func bool(forKey defaultName: String) -&gt; Bool {        let value = _get(forKey: defaultName)        return Bool(value ?? &quot;&quot;) ?? false    }    @objc public func url(forKey defaultName: String) -&gt; URL? {        let value = _get(forKey: defaultName)        return URL(string: value ?? &quot;&quot;)    }}// MARK: - HandyJSONextension StorageService {    public func set&lt;T&gt;(_ value: T, forKey defaultName: String) where T: HandyJSON {        set(value.toJSONString()!, forKey: defaultName)    }    public func model&lt;T&gt;(forKey defaultName: String) -&gt; T where T: HandyJSON {        let text: String = _get(forKey: defaultName) ?? &quot;&quot;        return T.deserialize(from: text) ?? T()    }    public func set&lt;T&gt;(_ value: [T], forKey defaultName: String) where T: HandyJSON {        set(value.toJSONString()!, forKey: defaultName)    }    public func models&lt;T&gt;(forKey defaultName: String) -&gt; [T] where T: HandyJSON {        let text: String = _get(forKey: defaultName) ?? &quot;&quot;        return ([T].deserialize(from: text) ?? []) as! [T]    }}// MARK: - 仅用于OCextension StorageService {    @available(*, deprecated, message: &quot;仅用于OC&quot;)    @objc public func setString(_ value: String, forKey defaultName: String) {        set(value, forKey: defaultName)    }}</code></pre><blockquote><p>总结</p></blockquote><ul><li><h5>利用AlecrimCoreData实现CoreData配置简易化</h5></li><li><h5>HandyJson作为中介者，存储到本地的为JsonString字符串，Json字符串与Model或者Models的转换</h5></li></ul><p><a href="https://github.com/luodeCoding/RoderCoreData" target="_blank" rel="noopener">Demo链接</a></p><p>Roder, <a href="https://luodecoding.github.io/" target="_blank" rel="noopener">我的博客</a> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用CoreData做项目数据持久化</title>
    <link href="undefined2020/06/03/%E4%BD%BF%E7%94%A8CoreData%E5%81%9A%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>2020/06/03/%E4%BD%BF%E7%94%A8CoreData%E5%81%9A%E9%A1%B9%E7%9B%AE%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2>CoreData数据持久化</h2><blockquote><p>概念</p></blockquote><h5>CoreData是Apple官方为iOS提供的一个数据持久化方案，其本质是一个通过封装底层数据操作，让程序员以面向对象的方式存储和管理数据的ORM框架（Object-Relational Mapping：对象-关系映射，简称ORM）。虽然底层支持SQLite、二进制数据、xml等多种文件存储，但是主要还是用来操作SQLite数据库。</h5><ul><li><h5>NSManagedObjectContext 是托管对象上下文，数据库的大多数操作是在这个类操作</h5></li><li><h5>NSManagedObjectModel 是托管对象模型，其中一个托管对象模型关联到一个模型文件，里面存储着数据库的数据结构。</h5></li><li><h5>NSPersistentStoreCoordinator 是持久化存储协调器，主要负责协调上下文玉存储的区域的关系。</h5></li><li><h5>NSManagedObject 是托管对象类，其中CoreData里面的托管对象都会继承此类。</h5></li></ul><blockquote><p>创建相关文件</p></blockquote>   <h4>两种方式</h4><ul><li><h5>如果创建项目的时候就勾选了UseCoreData也就会自动生成一个.xcdatamodeld后缀的文件</h5><p><img src="https://luodecoding.github.io/img/LearnCoreData/LearnCoreData01.png" srcset="/img/loading.gif" alt="image"></p></li><li><h5>如果已有项目中就需要手动去创建一个TestModel文件</h5><p> <img src="https://luodecoding.github.io/img/LearnCoreData/LearnCoreData02.png" srcset="/img/loading.gif" alt="image"></p></li></ul><blockquote><p>配置TestModel</p></blockquote><p>选中.xcdatamodeld文件</p><p><img src="https://luodecoding.github.io/img/LearnCoreData/LearnCoreData03.png" srcset="/img/loading.gif" alt="image"></p><ol><li><p>配置Person类的参数</p></li><li><p>配置关联数据</p></li><li><p>把它们看做数据库表 </p></li><li><p>设置Codegen：</p><ul><li><h5>选择Manual/None就需要手动去创建对应的类文件（Robot+CoreDataClass 和 Robot+CoreDataProperties）</h5></li><li><h5>选择Class Definition会在编译时生成这两个文件，不需要自己定义对应的类型</h5></li><li><h5>选择Category/Extension，在编译时只会默认生成Robot+CoreDataProperties文件，需要手动创建Robot+CoreDataClass定义该类型</h5></li></ul><p>注意：目前项目只用默认选择Class Definition</p></li></ol><blockquote><p>代码示例</p></blockquote><p>首先在AppDelegate文件里面创建persistentContainer</p><pre><code>lazy var persistentContainer: NSPersistentContainer = {        let container = NSPersistentContainer(name: &quot;TestModel&quot;)        container.loadPersistentStores { description, error in            if let error = error {                fatalError(&quot;Unable to load persistent stores: \(error)&quot;)            }        }        return container    }()</code></pre><p>在ViewController文件里面</p><ol><li><p>获取存储器上下文</p><pre><code>func getContext() -&gt; NSManagedObjectContext {                let appDelegate = UIApplication.shared.delegate as! AppDelegate                return appDelegate.persistentContainer.viewContext            }</code></pre></li><li><p>批量写入数据</p><pre><code>func inssertClasses() {        for i in 1...100 {            let classId = Int16(i)            let name = &quot;name&quot;+&quot;\(i)&quot;            insertClass(classId: classId, name: name)        }    }</code></pre></li><li><p>写入数据</p><pre><code>func insertClass(classId:Int16,name:String) {//获取上下文对象let context = getContext()//两种方式创建数据//1.创建一个实例并赋值let personEntity = NSEntityDescription.insertNewObject(forEntityName: &quot;Person&quot;, into: context) as! Person//Person对象赋值personEntity.id = classIdpersonEntity.name = name//2.通过指定实体名 得到对象实例let Entity = NSEntityDescription.entity(forEntityName: &quot;Person&quot;, in: context)let classEntity = NSManagedObject(entity: Entity!, insertInto: context)classEntity.setValue(classId, forKey: &quot;id&quot;)classEntity.setValue(name, forKey: &quot;name&quot;)//保存实体对象do {    try context.save()} catch  {    let nserror = error as NSError    fatalError(&quot;错误:\(nserror),\(nserror.userInfo)&quot;)}//获取Model缓存文件路径print(NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.applicationSupportDirectory, FileManager.SearchPathDomainMask.userDomainMask, true) )}</code></pre></li></ol><ol start="4"><li>使用NavicatPremium工具通过路径查看数据模型</li></ol><p>NavicatPremium工具：<a href="https://xclient.info/s/navicat-premium.html" target="_blank" rel="noopener">传送门</a></p><p><img src="https://luodecoding.github.io/img/LearnCoreData/LearnCoreData04.png" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Flutter学习-第四阶段</title>
    <link href="undefined2020/01/16/Flutter%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5/"/>
    <url>2020/01/16/Flutter%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ListView 列表</p></blockquote><p>一个线性布局的widgets列表</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Flutter学习-第三阶段</title>
    <link href="undefined2020/01/15/Flutter%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5/"/>
    <url>2020/01/15/Flutter%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h2>基础控件</h2><blockquote><p>Widget</p></blockquote><ol><li><p>介绍</p><ul><li>Widget实际上就是Element的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由Element构成；不过，由于Element是通过Widget生成的，所以它们之间有对应关系，在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。</li><li>一个Widget对象可以对应多个Element对象。这很好理解，根据同    一份配置（Widget），可以创建多个实例（Element）。</li></ul></li><li><p>StatelessWidget</p></li><li><p>StatefulWidget</p></li><li><p>State</p><ul><li>widget  </li><li>context</li></ul></li><li><p>回调函数</p><ul><li>initState：初始状态</li><li>didChangeDependencies()：当State对象的依赖发送变化时被调<br>用</li><li>build()：主要用于构建Wiget子树</li><li>reassemble()：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。</li><li>didUpdateWidget()：判断是否要刷新，回调这个方法</li><li>deactivate()：当State对象从树中被移除时，会调用此回调。</li><li>dispose()：当State对象从树中被永久移除时调用；通常在此回调中释放资源。</li></ul></li><li><p>注意</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Flutter学习-第二阶段</title>
    <link href="undefined2020/01/14/Flutter%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/"/>
    <url>2020/01/14/Flutter%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h2>应用</h2><blockquote><h4>路由管理</h4></blockquote><p>路由就是页面（page），在iOS中主要是指（ViewController）,路由 管理就是管理页面之间如何跳转，导航管理在Android还是iOS中，都是维护一个路由栈，push（打开新页面）和pop（关闭页面）页面；</p><pre><code>Navigator.push( context,           MaterialPageRoute(builder: (context) {              return NewRoute();           }));</code></pre><ol><li><p><u>Navigator</u> 路由管理的组件，通过一个栈来管理活动路由集合；</p></li><li><p><u>MaterialPageRoute</u> 继承自PageRoute类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。MaterialPageRoute 是Material组件库提供的组件，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画；</p><p>MaterialPageRoute({</p><pre><code>WidgetBuilder builder,RouteSettings settings,bool maintainState = true,bool fullscreenDialog = false,</code></pre><p>  })<br><u>builder</u> : 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。</p><p><u>settings</u> : 包含路由的配置信息，如路由名称、是否初始路由（首页）。</p><p><u>maintainState</u>：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为false。</p><p><u>fullscreenDialog</u>: 表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果fullscreenDialog为true，新页面将会从屏幕底部滑入（而不是水平方向）。</p></li><li><p>传值</p><pre><code>TipRoute({    Key key,    @required this.text,  // 接收一个text参数  }) : super(key: key);  final String text; /* 这里是TipRoute页面声明一个text值，准备接收；*/MaterialPageRoute(              builder: (context) {                return TipRoute(                  // 路由参数                  text: &quot;我是提示xxxx&quot;,                );              },            ),          ); /*这里是跳转TipRoute进行值传递*/</code></pre></li><li><p>命名路由</p><blockquote><p>注册路由表</p></blockquote><pre><code>routes:{ &quot;new_page&quot;:(context) =&gt; NewRoute(),  ... // 省略其它路由注册信息} </code></pre><blockquote><p>打开新路由</p></blockquote><pre><code>onPressed: () {  Navigator.pushNamed(context, &quot;new_page&quot;);},</code></pre><blockquote><p>命名路由参数传递</p></blockquote><pre><code> Navigator.of(context).pushNamed(&quot;new_page&quot;, arguments: &quot;hi&quot;);/*打开路由时传递参数*/ class Route extends StatelessWidget {  @override  Widget build(BuildContext context) {    //获取路由参数      var args=ModalRoute.of(context).settings.arguments;    //...省略无关代码  }} /*打开后路由获取路由参数*/</code></pre></li><li><p>路由器生成钩子</p><blockquote><p>onGenerateRoute回调</p></blockquote><pre><code>MaterialApp(  ... //省略无关代码  onGenerateRoute:(RouteSettings settings){      return MaterialPageRoute(builder: (context){           String routeName = settings.name;       // 如果访问的路由页需要登录，但当前未登录，则直接返回登录页路由，       // 引导用户登录；其它情况则正常打开路由。     }   );  });</code></pre></li></ol><blockquote><h4>包管理</h4></blockquote><ul><li>name：应用或包名称</li><li>description：应用或包的描述、简介</li><li>version：应用或包的版本号</li><li>dev_dependencies：开发环境依赖的工具包（而不是flutter应用本身依赖的包）</li><li>flutter：flutter相关的配置选项</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Flutter学习-第一阶段</title>
    <link href="undefined2020/01/10/Flutter%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/"/>
    <url>2020/01/10/Flutter%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="Flutter第一阶段"><a href="#Flutter第一阶段" class="headerlink" title="Flutter第一阶段"></a>Flutter第一阶段</h2><blockquote><h3>环境配置 注意事项</h3></blockquote><h5>1.官方文档中当你把flutter下载到电脑之后，要想全局命令运行flutter，需要配置环境变量 </h5><pre><code>export PATH=$PATH:/Users/roder/Desktop/flutter/bin</code></pre><h6>这里注意 ：$PATH:后面的是你下载的flutter里面的bin的路径，可以通过找到bin这个文件夹拖到终端命令里面就会自动显示该路径。</h6><h5>2.打开终端执行</h5><pre><code>open ~/.bash_profile</code></pre><h6>弹出一个编辑框后，把第一步的路径复制进去，保存。</h6><h5>3.再在终端执行</h5><pre><code>source .bash_profile</code></pre><h6>基本上到这一步都是可以了，但是如果你的终端命令配置的是zshrc ，那么就需要，继续看下面</h6><h5>4.在终端执行</h5><pre><code>open .zshrc</code></pre><h5>5.弹出编辑框后，再把第一步的路径粘贴进去，换行，把第3步的命令粘贴进去，保存，再执行</h5><pre><code>source .zshrc</code></pre><h6>最后验证在终端执行</h6><pre><code>flutter doctor</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>隐私政策</title>
    <link href="undefined2019/12/19/%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/"/>
    <url>2019/12/19/%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/</url>
    
    <content type="html"><![CDATA[<p>本应用非常重视用户隐私政策并严格遵守相关的法律规定。请您仔细阅读《隐私政策》后再继续使用。如果您继续使用我们的服务，表示您已经充分阅读和理解我们协议的全部内容。</p><p>本app尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更优质的服务，本应用会按照本隐私权政策的规定使用和披露您的个人信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本应用不会将这些信息对外披露或向第三方提供。本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。</p><ol><li>适用范围</li></ol><p>(a) 在您注册本应用app帐号时，您根据app要求提供的个人注册信息；</p><p>(b) 在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器和计算机上的信息，包括但不限于您的IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息及您需求的网页记录等数据；</p><p>(c) 本应用通过合法途径从商业伙伴处取得的用户个人数据。</p><p>(d)本应用严禁用户发布不良信息，如裸露、色情和亵渎内容，发布的内容我们会进行审核，一经发现不良信息，会禁用该用户的所有权限，予以封号处理。</p><ol start="2"><li>信息使用</li></ol><p>(a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人登录信息。如果我们存储发生维修或升级，我们会事先发出推送消息来通知您，请您提前允许本应用消息通知。</p><p>(b) 本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。</p><p>(c) 为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。</p><ol start="3"><li>信息披露</li></ol><p>在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息：</p><p>(a) 未经您事先同意，我们不会向第三方披露；</p><p>(b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息；</p><p>(c) 根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p><p>(d) 如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向第三方披露；</p><p>(e) 如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷；</p><ol start="4"><li>信息存储和交换</li></ol><p>本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。</p><ol start="5"><li>Cookie的使用</li></ol><p>(a) 在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。</p><p>(b) 您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。</p><p>(c) 通过本应用所设cookies所取得的有关信息，将适用本政策。</p><p>6.本隐私政策的更改</p><p>(a)如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。</p><p>(b)本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。</p><p>方披露自己的个人信息，如联络方式或者邮政地址。请您妥善保护自己的个人信息，仅在必要的情形下向他人提供。如您发现自己的个人信息泄密，尤其是本应用用户名及密码发生泄露，请您立即联络本应用客服，以便本应用采取相应措施。</p><p>感谢您花时间了解我们的隐私政策！我们将尽全力保护您的个人信息和合法权益，再次感谢您的信任！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RxSwift+Moya网络请求框架改进版</title>
    <link href="undefined2019/10/28/RxSwift-Moya%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6%E6%94%B9%E8%BF%9B%E7%89%88/"/>
    <url>2019/10/28/RxSwift-Moya%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6%E6%94%B9%E8%BF%9B%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2>改进版</h2><blockquote><p>改进原因</p></blockquote><h5>由于实际项目中接口虽然多样化，但大部分的接口请求的基本类型不会有很大的变化，我们可以将Moya的TargetType重写一个父类，这样在项目中我们可以更好地对接口进行管理</h5><p>####待更新</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RxSwift、Alamofire、Moya和HandyJson的结合使用</title>
    <link href="undefined2019/04/19/SwiftNetWorkWith-MoyaAndHandyJson/"/>
    <url>2019/04/19/SwiftNetWorkWith-MoyaAndHandyJson/</url>
    
    <content type="html"><![CDATA[<h2>打造swift网络框架</h2><blockquote><p>准备工作</p></blockquote><ul><li><h5>使用CocoaPods工具Pod需要使用的相关框架</h5></li></ul><p>具体的pod用法在这里就不做详解了，如有不懂可以查阅 <a href="https://www.jianshu.com/p/b656c3c59af5" target="_blank" rel="noopener">CocoaPods使用</a></p><pre><code>pod &apos;Alamofire&apos; pod &apos;Moya/RxSwift&apos;pod &apos;HandyJSON&apos;, &apos;~&gt; 5.0.0-beta.1&apos;</code></pre><blockquote><p>创建文件</p></blockquote><ul><li><h5>APIManager</h5></li></ul><pre><code>////  APIManager.swift//  SwiftNetWorkHelper////  Created by 罗德良 on 2019/4/10.//  Copyright © 2019 swagTeam. All rights reserved.//import Foundationimport Moyaenum APIManager {    case testApi    case testApiPara(para1:String,para2:String)    case testApiDict(Dict:[String:Any])    case getNbaInfo(getKey:String)}extension APIManager:TargetType {    var baseURL: URL {        return URL.init(string: &quot;http://op.juhe.cn/onebox/basketball/&quot;)!    }    var path: String {        switch self {        case .testApi:            return &quot;nba&quot;        case .testApiPara(let para1, let para2):            return &quot;nba&quot;        case .testApiDict:            return &quot;nba&quot;        case .getNbaInfo:            return &quot;nba&quot;        }    }    var method: Moya.Method {        switch self {        case .testApi:            return .get        default:            return .post        }    }    var sampleData: Data {        return &quot;&quot;.data(using: String.Encoding.utf8)!    }    var task: Task {        switch self {        case .testApi:            return .requestPlain        case let .testApiPara(para1, _):            return .requestParameters(parameters: [&quot;key&quot; : para1], encoding: URLEncoding.default)        case .testApiDict(let dict):            return .requestParameters(parameters: dict, encoding: JSONEncoding.default)        case .getNbaInfo(let getKey):            return .requestParameters(parameters: [&quot;key&quot; : getKey], encoding: URLEncoding.default)        }    }    var headers: [String : String]? {        return [&quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;]    }}</code></pre><ul><li><h5>RxHandyJSON</h5></li></ul><pre><code>////  RxHandyJSON.swift//  SwiftNetWorkHelper////  Created by 罗德良 on 2019/4/10.//  Copyright © 2019 swagTeam. All rights reserved.//import Foundationimport RxSwiftimport HandyJSONimport Moyaenum DCUError : Swift.Error {    case ParseJSONError    case RequestFailed    case NoResponse    case UnexpectedResult(resultCode: Int?,resultMsg:String?)}enum RequestStatus: Int {    case requestSuccess = 200    case requestError}fileprivate let RESULT_CODE = &quot;code&quot;fileprivate let RESULT_MSG = &quot;reason&quot;fileprivate let RESULT_DATA = &quot;result&quot;public extension Observable {    func mapResponseToObject&lt;T: HandyJSON&gt;(type: T.Type) -&gt; Observable&lt;T&gt; {        return map { response in            guard let response = response as? Moya.Response                else {                    throw DCUError.NoResponse            }            guard ((200...209) ~= response.statusCode) else {                throw DCUError.RequestFailed            }            let jsonData = try response.mapJSON() as! [String : Any]            if let code = jsonData[RESULT_MSG] as? String {                if code == &quot;查询成功&quot; {                    if let model = JSONDeserializer&lt;T&gt;.deserializeFrom(dict: jsonData){                        return model                    }                }            }}</code></pre><ul><li><h5>TestModel</h5><pre><code>////  TestModel.swift//  SwiftNetWorkHelper////  Created by 罗德良 on 2019/4/10.//  Copyright © 2019 swagTeam. All rights reserved.//import HandyJSONstruct TestModel: HandyJSON {    var reason :String = &quot;&quot;    var result :String = &quot;&quot;}</code></pre></li></ul><blockquote><p>实现效果</p></blockquote><pre><code>let rxProvider = MoyaProvider&lt;APIManager&gt;()        rxProvider.rx.request(.getNbaInfo(getKey: &quot;537f7b3121a797c8d18f4c0523f3c124&quot;)).asObservable().mapResponseToObject(type: TestModel.self)            .subscribe { (test) in                print(test)                let model = test.element                print(model?.reason ?? String.self)        }        .disposed(by: disposeBag)</code></pre><blockquote><p>总结</p></blockquote><p><a href="https://github.com/luodeCoding/SwiftNetWorkHelper" target="_blank" rel="noopener">Demo链接</a></p><ul><li><h5>APIManager作为接口内容配置，通过接口地址以及接口数据的组建</h5></li><li><h5>RxHandyJSON作为由于Moya对HandyJson没有扩展，自己实现的扩展，该文件可以根据后台接口定义做调整</h5></li><li><h5>TestModel作为基础数据格式，该处可以创建一个BaseModel，根据后台返回数据进行调整，会有更好的扩展性</h5></li></ul><p>Roder, <a href="https://luodecoding.github.io/" target="_blank" rel="noopener">我的博客</a> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>通知栏扩展学习</title>
    <link href="undefined2018/11/12/%E9%80%9A%E7%9F%A5%E6%A0%8F%E6%89%A9%E5%B1%95%E5%AD%A6%E4%B9%A0/"/>
    <url>2018/11/12/%E9%80%9A%E7%9F%A5%E6%A0%8F%E6%89%A9%E5%B1%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2>iOS的Extension Widget开发</h2><h3>1 、初始化Today Extension项目</h3><ul><li><h5>新建项目</h5></li></ul><p><img src="https://luodecoding.github.io/img/ExtensionWidget/AppGroupsExtensionWidget1.png" srcset="/img/loading.gif" alt="image"></p><p><img src="https://luodecoding.github.io/img/ExtensionWidget/NewExtensionWidget2.png" srcset="/img/loading.gif" alt="image"></p><ul><li><h5>布局方式</h5></li></ul><blockquote><p>storeyboard布局</p></blockquote><pre><code>MainInterface.storeybord</code></pre><p><img src="https://luodecoding.github.io/img/ExtensionWidget/UIExtensionWidget1.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>纯代码编写</p></blockquote><pre><code>需要配置info.plist的俩项参数移除NSExtensionMainStoryboard键，并添加NSExtensionPrincipalClass键，使用view controller的名字作为值。</code></pre><p><img src="https://luodecoding.github.io/img/ExtensionWidget/UIExtensionWidget2.png" srcset="/img/loading.gif" alt="image"></p><ul><li><h5>折叠功能</h5><pre><code>- (void)viewWillAppear:(BOOL)animated {             [super viewWillAppear:animated];            self.extensionContext.widgetLargestAvailableDisplayMode =     NCWidgetDisplayModeExpanded;    }</code></pre></li></ul><ul><li><h5>隐藏Today Extension</h5><pre><code>NCWidgetController *widgetController = [NCWidgetController widgetController];[widgetController setHasContent:NO forWidgetWithBundleIdentifier:@&quot;扩展的id&quot;];</code></pre></li></ul><ul><li><h5>NCWidgetProviding代理</h5></li></ul><blockquote><p>折叠代理</p></blockquote><pre><code>- (void)widgetActiveDisplayModeDidChange:(NCWidgetDisplayMode)activeDisplayMode withMaximumSize:(CGSize)maxSize {if (activeDisplayMode == NCWidgetDisplayModeCompact){ self.preferredContentSize = CGSizeMake([UIScreen mainScreen].bounds.size.width, 110); } else { self.preferredContentSize = CGSizeMake([UIScreen mainScreen].bounds.size.width, 300); }}</code></pre><blockquote><p>缩进</p></blockquote><pre><code>- (UIEdgeInsets)widgetMarginInsetsForProposedMarginInsets: (UIEdgeInsets)defaultMarginInsets {return UIEdgeInsetsZero;}</code></pre><blockquote><p>刷新Today Extension页面</p></blockquote><pre><code>- (void)widgetPerformUpdateWithCompletionHandler:(void (^)(NCUpdateResult))completionHandler {// Perform any setup necessary in order to update the view.// If an error is encountered, use NCUpdateResultFailed// If there&apos;s no update required, use NCUpdateResultNoData// If there&apos;s an update, use NCUpdateResultNewDatacompletionHandler(NCUpdateResultNewData);}</code></pre><h3>2 、 与APP交互</h3><ul><li><h5>跳转APP</h5></li></ul><blockquote><p>APP设置URL Schemes</p></blockquote><p><img src="https://luodecoding.github.io/img/ExtensionWidget/ExtensionWidget6.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>Today Extension实现跳转</p></blockquote><pre><code>- (void)jumpHomeAppEvents {    NSString *schemeString = @&quot;demo://&quot;;    [self.extensionContext openURL:[NSURL URLWithString:schemeString] completionHandler:^(BOOL success) {    }];}</code></pre><h3>3 、 与APP共享数据 </h3><ul><li><h5>创建APPGroups</h5></li></ul><blockquote><p>登录appdeveloper网站创建APPGroups</p></blockquote><p><img src="https://luodecoding.github.io/img/ExtensionWidget/AppGroupsExtensionWidget1.png" srcset="/img/loading.gif" alt="image"></p><p><img src="https://luodecoding.github.io/img/ExtensionWidget/AppGroupsExtensionWidget2.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>Xcode设置APPGroups</p></blockquote><p><img src="https://luodecoding.github.io/img/ExtensionWidget/AppGroupsExtensionWidget3.png" srcset="/img/loading.gif" alt="image"></p><blockquote><p>APP存储数据</p></blockquote><pre><code>- (void)saveDataByNSUserDefaults{    NSUserDefaults* userDefault = [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.listennba.appGroup&quot;];    [userDefault setValue:@&quot;你好，通知栏扩展&quot; forKey:@&quot;haha&quot;];}</code></pre><blockquote><p>Today Extension读取数据</p></blockquote><pre><code>- (void)readDataFromNSUserDefaults{    NSUserDefaults * userDefault = [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.listennba.appGroup&quot;];    NSLog(@&quot;读取出的数据为：%@&quot;,[myDefaults objectForKey:@&quot;haha&quot;]);}</code></pre><blockquote><p>实例</p></blockquote><p><img src="https://luodecoding.github.io/img/ExtensionWidget/AppGroupsExtensionWidget4.png" srcset="/img/loading.gif" alt="image"></p><p><img src="https://luodecoding.github.io/img/ListenToNBA/ListenNBADemo4.png" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>swfit问题总结一</title>
    <link href="undefined2018/11/06/swfit%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E4%B8%80/"/>
    <url>2018/11/06/swfit%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>swift项目桥接OC第三方库</p></blockquote><h6 id="言归正传，先上图-–-gt"><a href="#言归正传，先上图-–-gt" class="headerlink" title="言归正传，先上图 –&gt;"></a>言归正传，先上图 –&gt;</h6><ol><li>创建.h文件</li></ol><p><img src="https://luodecoding.github.io/img/swiftBridgeOcImg/swiftBridgeOc1.png" srcset="/img/loading.gif" alt="image"></p><ol start="2"><li>在本项目的taget下路径：target-&gt;Build Setting-&gt;Search Path-&gt;User Header Search Paths 设置目录的路径${SRCROOT},然后选择recursive</li></ol><p><img src="https://luodecoding.github.io/img/swiftBridgeOcImg/swiftBridgeOc3.png" srcset="/img/loading.gif" alt="image"><br>3. 在本项目的taget下路径：target-&gt;Build Setting-&gt;Swift Compiler - General -&gt;Objective-C Bridging Header 双击输入<br><code>$(SRCROOT)/本项目名称/xxx.h</code></p><p><img src="https://luodecoding.github.io/img/swiftBridgeOcImg/swiftBridgeOc2.png" srcset="/img/loading.gif" alt="image"></p><ol start="4"><li>在Pod的taget下路径：target-&gt;Build Setting-&gt;Search Path-&gt;User Header Search Paths 设置目录的路径${SRCROOT},然后选择recursive</li></ol><p><img src="https://luodecoding.github.io/img/swiftBridgeOcImg/swiftBridgeOc4.png" srcset="/img/loading.gif" alt="image"></p><h1>这样就大功靠成了，可以在桥接文件随便import第三方库的东西啦！！！<h1/>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>listenToNBABlog</title>
    <link href="undefined2018/10/23/listenToNBABlog/"/>
    <url>2018/10/23/listenToNBABlog/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-ListenToNBA-APP"><a href="#iOS-ListenToNBA-APP" class="headerlink" title="iOS ListenToNBA APP"></a>iOS ListenToNBA APP</h1><blockquote><p>观看NBA直播并支持后台收听功能的APP</p></blockquote><h1>结构</h1><h3>本项目使用Object-C开发，共分为三个部分。</h3><ol><li>基础页面布局（包含首页的Banner和列表展示以及webview相关内容）；</li><li>数据方面（采用第三方SDK：LeanCloud，在平台端建表录入数据，APP端获取即可）；</li><li>直播控件开发（围绕AVPlayer展开）</li></ol><h1>展示图</h1><p><img src="https://luodecoding.github.io/img/ListenToNBA/ListenNBADemo1.png" srcset="/img/loading.gif" alt="image"><br><img src="https://luodecoding.github.io/img/ListenToNBA/ListenNBADemo2.png" srcset="/img/loading.gif" alt="image"><br><img src="https://luodecoding.github.io/img/ListenToNBA/ListenNBADemo3.png" srcset="/img/loading.gif" alt="image"><br><img src="https://luodecoding.github.io/img/ListenToNBA/ListenNBADemo4.png" srcset="/img/loading.gif" alt="image"></p><h1>目录</h1><blockquote><p>基础页面布局</p></blockquote><h4>内容</h4><blockquote><p>基础数据</p></blockquote><h4>内容</h4><blockquote><p>直播控件开发</p></blockquote><h4>内容</h4><p><a href="https://github.com/luodeCoding/ListenToNBA" target="_blank" rel="noopener">Demo链接</a></p><p>Roder, <a href="https://luodecoding.github.io/" target="_blank" rel="noopener">我的博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>